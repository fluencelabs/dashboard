import "@fluencelabs/aqua-lib/builtin.aqua"

alias FakeTuple: u64
alias PeerInfoCb: PeerId, Info, []Service, []Blueprint, []Module -> ()
alias ServiceInterfaceCb: PeerId, *FakeTuple -> ()
alias Log: string -> ()

service MyOp("op"):
	array(s: string, i: Interface) -> FakeTuple

func collectServiceInterfaces(peer: PeerId, services: []Service, collectServiceInterface: ServiceInterfaceCb, log: Log):
	ifaces: *FakeTuple
	on peer:
		for srv <- services:
			iface <- Srv.get_interface(srv.id)
			ifaces <- MyOp.array(srv.id, iface)
	collectServiceInterface(peer, ifaces)

func askAllAndSend(peer: PeerId, collectPeerInfo: PeerInfoCb, collectServiceInterface: ServiceInterfaceCb, log: Log):
	on peer via HOST_PEER_ID:
		ident <- Peer.identify()
		blueprints <- Dist.list_blueprints()
		modules <- Dist.list_modules()
		services <- Srv.list()
		co collectPeerInfo(peer, ident, services, blueprints, modules)
		collectServiceInterfaces(peer, services, collectServiceInterface, log)

func findAndAskNeighboursSchema(relayPeerId: PeerId, clientId: PeerId, collectPeerInfo: PeerInfoCb, collectServiceInterface: ServiceInterfaceCb, log: Log):
	on relayPeerId:
		neighbors <- Kademlia.neighborhood(clientId, nil, nil)
		for n <- neighbors par:
			on n:
				neighbors2 <- Kademlia.neighborhood(clientId, nil, nil)
				for n2 <- neighbors2 par:
					askAllAndSend(n2, collectPeerInfo, collectServiceInterface, log)

func getAll(knownPeers: []PeerId, collectPeerInfo: PeerInfoCb, collectServiceInterface: ServiceInterfaceCb, log: Log):
	on HOST_PEER_ID:
		-- co askAllAndSend(relayPeerId, collectPeerInfo, collectServiceInterface)
		
		-- in order to temporarily reduce the number of particles sent to client 
		-- we gather data from the known peers only. 
		-- Known peers are explicitly represent the whole network atm
		for peer <- knownPeers par:
			askAllAndSend(peer, collectPeerInfo, collectServiceInterface, log)

		-- co findAndAskNeighboursSchema(relayPeerId, %init_peer_id%, collectPeerInfo, collectServiceInterface)
