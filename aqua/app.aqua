import "@fluencelabs/aqua-lib/builtin.aqua"

alias PeerInfoCb: PeerId, Info, []Service, []Blueprint, []Module -> ()
alias ServiceInterfaceCb: PeerId, string, Interface -> ()

func collectServiceInterfaces(peer: PeerId, services: []Service, collectServiceInterface: ServiceInterfaceCb):
	for srv <- services par:
		iface <- Srv.get_interface(srv.id)
		collectServiceInterface(peer, srv.id, iface)

func askAllAndSend(peer: PeerId, collectPeerInfo: PeerInfoCb, collectServiceInterface: ServiceInterfaceCb):
	ident <- Peer.identify()
	blueprints <- Dist.list_blueprints()
	modules <- Dist.list_modules()
	services <- Srv.list()
	collectPeerInfo(peer, ident, services, blueprints, modules)
	-- collectServiceInterfaces(peer, services, collectServiceInterface)


func findAndAskNeighboursSchema(
	clientId: PeerId, 
	collectPeerInfo: PeerInfoCb, 
	collectServiceInterface: ServiceInterfaceCb,
	logNeighs: []string -> (),
	logFail: string, string -> ()
):
	on HOST_PEER_ID:
		neighbors <- Kademlia.neighborhood(clientId, nil, nil)
		-- co logNeighs(neighbors)
		for n <- neighbors par:
			on n:
				neighbors2 <- Kademlia.neighborhood(n, nil, nil)
				-- co logNeighs(neighbors2)
				for n2 <- neighbors2 par:
					connected <- Peer.connect(n2, nil)
					if connected:
						status: *string
						par on n2:
							-- askAllAndSend(n2, collectPeerInfo, collectServiceInterface)
							Peer.identify()
							status <<- "done"
						status <- Peer.timeout(1000, "timedout")
						if status! == "done":
							logFail("success", n2)
						else:
							logFail("timed out", n2)
					else:
							logFail("failed to connect", n2)


func getAll(
	knownPeers: []PeerId, 
	collectPeerInfo: PeerInfoCb, 
	collectServiceInterface: ServiceInterfaceCb,
	logNeighs: []string -> (),
	logFail: string, string -> ()
):
	on HOST_PEER_ID:
		-- co askAllAndSend(relayPeerId, collectPeerInfo, collectServiceInterface)
		
		-- in order to temporarily reduce the number of particles sent to client 
		-- we gather data from the known peers only. 
		-- Known peers are explicitly represent the whole network atm
		-- for peer <- knownPeers par:
		-- 	askAllAndSend(peer, collectPeerInfo, collectServiceInterface)

		co findAndAskNeighboursSchema(%init_peer_id%, collectPeerInfo, collectServiceInterface, logNeighs, logFail)
