import "@fluencelabs/aqua-lib/builtin.aqua"

alias PeerInfoCb: PeerId, Info, []Service, []Blueprint, []Module -> ()
alias ServiceInterfaceCb: PeerId, string, Interface -> ()

-- send all found ServiceInterface-s to the client
func collectServiceInterfaces(peer: PeerId, services: []Service, collectServiceInterface: ServiceInterfaceCb):
	for srv <- services par:
		on peer:
			iface <- Srv.get_interface(srv.id)
			collectServiceInterface(peer, srv.id, iface)

-- retrieve PeerInfo & ServiceInterface-s from a single peer
func askAllAndSend(peer: PeerId, collectPeerInfo: PeerInfoCb, collectServiceInterface: ServiceInterfaceCb):
	on peer:
		ident <- Peer.identify()
		blueprints <- Dist.list_blueprints()
		modules <- Dist.list_modules()
		services <- Srv.list()
		collectPeerInfo(peer, ident, services, blueprints, modules)
		collectServiceInterfaces(peer, services, collectServiceInterface)

-- retrieve PeerInfo and ServiceInterface-s from each peer in `peers`
func getServicesFromPeers(
	peers: []PeerId,
	collectPeerInfo: PeerInfoCb, 
	collectServiceInterface: ServiceInterfaceCb
):
	for peer <- peers par:
		askAllAndSend(peer, collectPeerInfo, collectServiceInterface)

-- discover new nodes in the network and report findings back to client
func discoverNeighbourhood(relay: PeerId, collectNeighbors: []string -> ()):
	on relay:
		neighbors <- Kademlia.neighborhood(%init_peer_id%, nil, nil)
		co collectNeighbors(neighbors)
		for n <- neighbors par:
			on n:
				neighbors2 <- Kademlia.neighborhood(%init_peer_id%, nil, nil)
				collectNeighbors(neighbors2)

func getAll(
	relay: PeerId, 
	knownPeers: []PeerId, 
	collectPeerInfo: PeerInfoCb, 
	collectServiceInterface: ServiceInterfaceCb,
	collectNeighbors: []string -> ()
):
	co askAllAndSend(relay, collectPeerInfo, collectServiceInterface)
	
	for peer <- knownPeers par:
		askAllAndSend(peer, collectPeerInfo, collectServiceInterface)

	co discoverNeighbourhood(relay, collectNeighbors)
