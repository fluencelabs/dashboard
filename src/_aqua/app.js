/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/. 
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.3.1-231
 *
 */
import { Fluence, FluencePeer } from '@fluencelabs/fluence';
import {
    ResultCodes,
    RequestFlow,
    RequestFlowBuilder,
    CallParams,
} from '@fluencelabs/fluence/dist/internal/compilerSupport/v1.js';


function missingFields(obj, fields) {
    return fields.filter(f => !(f in obj))
}

// Services


// Functions

 export function collectServiceInterfaces(...args) {
     let peer;
     let peer_;
let services;
let collectServiceInterface;
     let config;
     if (FluencePeer.isInstance(args[0])) {
         peer = args[0];
         peer_ = args[1];
services = args[2];
collectServiceInterface = args[3];
config = args[4];
     } else {
         peer = Fluence.getPeer();
         peer_ = args[0];
services = args[1];
collectServiceInterface = args[2];
config = args[3];
     }
    
     let request;
     const promise = new Promise((resolve, reject) => {
         const r = new RequestFlowBuilder()
                 .disableInjections()
                 .withRawScript(
                     `
     (xor
 (seq
  (seq
   (seq
    (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
    (call %init_peer_id% ("getDataSrv" "peer") [] peer)
   )
   (call %init_peer_id% ("getDataSrv" "services") [] services)
  )
  (fold services srv
   (par
    (seq
     (call -relay- ("op" "noop") [])
     (xor
      (seq
       (seq
        (call peer ("srv" "get_interface") [srv.$.id!] iface)
        (call -relay- ("op" "noop") [])
       )
       (xor
        (call %init_peer_id% ("callbackSrv" "collectServiceInterface") [peer srv.$.id! iface])
        (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
       )
      )
      (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
     )
    )
    (next srv)
   )
  )
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 3])
)

                 `,
                 )
                 .configHandler((h) => {
                     h.on('getDataSrv', '-relay-', () => {
                    return peer.getStatus().relayPeerId;
                });
                h.on('getDataSrv', 'peer', () => {return peer_;});
h.on('getDataSrv', 'services', () => {return services;});

 h.use((req, resp, next) => {
 if(req.serviceId === 'callbackSrv' && req.fnName === 'collectServiceInterface') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         arg0: req.tetraplets[0],arg1: req.tetraplets[1],arg2: req.tetraplets[2]
     },
 };
 resp.retCode = ResultCodes.success;
 collectServiceInterface(req.args[0], req.args[1], req.args[2], callParams); resp.result = {}

 }
 next();
 });
        
                h.onEvent('callbackSrv', 'response', (args) => {
  
});

                h.onEvent('errorHandlingSrv', 'error', (args) => {
                    const [err] = args;
                    reject(err);
                });
            })
            .handleScriptError(reject)
            .handleTimeout(() => {
                reject('Request timed out for collectServiceInterfaces');
            })
        if(config && config.ttl) {
            r.withTTL(config.ttl)
        }
        request = r.build();
    });
    peer.internals.initiateFlow(request);
    return Promise.race([promise, Promise.resolve()]);
}
      


 export function askAllAndSend(...args) {
     let peer;
     let peer_;
let collectPeerInfo;
let collectServiceInterface;
     let config;
     if (FluencePeer.isInstance(args[0])) {
         peer = args[0];
         peer_ = args[1];
collectPeerInfo = args[2];
collectServiceInterface = args[3];
config = args[4];
     } else {
         peer = Fluence.getPeer();
         peer_ = args[0];
collectPeerInfo = args[1];
collectServiceInterface = args[2];
config = args[3];
     }
    
     let request;
     const promise = new Promise((resolve, reject) => {
         const r = new RequestFlowBuilder()
                 .disableInjections()
                 .withRawScript(
                     `
     (xor
 (seq
  (seq
   (seq
    (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
    (call %init_peer_id% ("getDataSrv" "peer") [] peer)
   )
   (call -relay- ("op" "noop") [])
  )
  (xor
   (seq
    (seq
     (seq
      (seq
       (seq
        (seq
         (seq
          (call peer ("peer" "identify") [] ident)
          (call peer ("dist" "list_blueprints") [] blueprints)
         )
         (call peer ("dist" "list_modules") [] modules)
        )
        (call peer ("srv" "list") [] services)
       )
       (call -relay- ("op" "noop") [])
      )
      (xor
       (call %init_peer_id% ("callbackSrv" "collectPeerInfo") [peer ident services blueprints modules])
       (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
      )
     )
     (call -relay- ("op" "noop") [])
    )
    (fold services srv
     (par
      (seq
       (call -relay- ("op" "noop") [])
       (xor
        (seq
         (seq
          (call peer ("srv" "get_interface") [srv.$.id!] iface)
          (call -relay- ("op" "noop") [])
         )
         (xor
          (call %init_peer_id% ("callbackSrv" "collectServiceInterface") [peer srv.$.id! iface])
          (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
         )
        )
        (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 3])
       )
      )
      (seq
       (call -relay- ("op" "noop") [])
       (next srv)
      )
     )
    )
   )
   (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 4])
  )
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 5])
)

                 `,
                 )
                 .configHandler((h) => {
                     h.on('getDataSrv', '-relay-', () => {
                    return peer.getStatus().relayPeerId;
                });
                h.on('getDataSrv', 'peer', () => {return peer_;});

 h.use((req, resp, next) => {
 if(req.serviceId === 'callbackSrv' && req.fnName === 'collectPeerInfo') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         arg0: req.tetraplets[0],arg1: req.tetraplets[1],arg2: req.tetraplets[2],arg3: req.tetraplets[3],arg4: req.tetraplets[4]
     },
 };
 resp.retCode = ResultCodes.success;
 collectPeerInfo(req.args[0], req.args[1], req.args[2], req.args[3], req.args[4], callParams); resp.result = {}

 }
 next();
 });
        

 h.use((req, resp, next) => {
 if(req.serviceId === 'callbackSrv' && req.fnName === 'collectServiceInterface') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         arg0: req.tetraplets[0],arg1: req.tetraplets[1],arg2: req.tetraplets[2]
     },
 };
 resp.retCode = ResultCodes.success;
 collectServiceInterface(req.args[0], req.args[1], req.args[2], callParams); resp.result = {}

 }
 next();
 });
        
                h.onEvent('callbackSrv', 'response', (args) => {
  
});

                h.onEvent('errorHandlingSrv', 'error', (args) => {
                    const [err] = args;
                    reject(err);
                });
            })
            .handleScriptError(reject)
            .handleTimeout(() => {
                reject('Request timed out for askAllAndSend');
            })
        if(config && config.ttl) {
            r.withTTL(config.ttl)
        }
        request = r.build();
    });
    peer.internals.initiateFlow(request);
    return Promise.race([promise, Promise.resolve()]);
}
      


 export function findAndAskNeighboursSchema(...args) {
     let peer;
     let relayPeerId;
let clientId;
let collectPeerInfo;
let collectServiceInterface;
     let config;
     if (FluencePeer.isInstance(args[0])) {
         peer = args[0];
         relayPeerId = args[1];
clientId = args[2];
collectPeerInfo = args[3];
collectServiceInterface = args[4];
config = args[5];
     } else {
         peer = Fluence.getPeer();
         relayPeerId = args[0];
clientId = args[1];
collectPeerInfo = args[2];
collectServiceInterface = args[3];
config = args[4];
     }
    
     let request;
     const promise = new Promise((resolve, reject) => {
         const r = new RequestFlowBuilder()
                 .disableInjections()
                 .withRawScript(
                     `
     (xor
 (seq
  (seq
   (seq
    (seq
     (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
     (call %init_peer_id% ("getDataSrv" "relayPeerId") [] relayPeerId)
    )
    (call %init_peer_id% ("getDataSrv" "clientId") [] clientId)
   )
   (call -relay- ("op" "noop") [])
  )
  (xor
   (seq
    (call relayPeerId ("kad" "neighborhood") [clientId [] []] neighbors)
    (fold neighbors n
     (par
      (xor
       (seq
        (call n ("kad" "neighborhood") [clientId [] []] neighbors2)
        (fold neighbors2 n2
         (par
          (seq
           (call -relay- ("op" "noop") [])
           (xor
            (seq
             (seq
              (seq
               (seq
                (seq
                 (seq
                  (seq
                   (call n2 ("peer" "identify") [] ident)
                   (call n2 ("dist" "list_blueprints") [] blueprints)
                  )
                  (call n2 ("dist" "list_modules") [] modules)
                 )
                 (call n2 ("srv" "list") [] services)
                )
                (call -relay- ("op" "noop") [])
               )
               (xor
                (call %init_peer_id% ("callbackSrv" "collectPeerInfo") [n2 ident services blueprints modules])
                (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
               )
              )
              (call -relay- ("op" "noop") [])
             )
             (fold services srv
              (par
               (seq
                (call -relay- ("op" "noop") [])
                (xor
                 (seq
                  (seq
                   (call n2 ("srv" "get_interface") [srv.$.id!] iface)
                   (call -relay- ("op" "noop") [])
                  )
                  (xor
                   (call %init_peer_id% ("callbackSrv" "collectServiceInterface") [n2 srv.$.id! iface])
                   (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
                  )
                 )
                 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 3])
                )
               )
               (seq
                (call -relay- ("op" "noop") [])
                (next srv)
               )
              )
             )
            )
            (seq
             (call -relay- ("op" "noop") [])
             (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 4])
            )
           )
          )
          (next n2)
         )
        )
       )
       (seq
        (call -relay- ("op" "noop") [])
        (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 5])
       )
      )
      (next n)
     )
    )
   )
   (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 6])
  )
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 7])
)

                 `,
                 )
                 .configHandler((h) => {
                     h.on('getDataSrv', '-relay-', () => {
                    return peer.getStatus().relayPeerId;
                });
                h.on('getDataSrv', 'relayPeerId', () => {return relayPeerId;});
h.on('getDataSrv', 'clientId', () => {return clientId;});

 h.use((req, resp, next) => {
 if(req.serviceId === 'callbackSrv' && req.fnName === 'collectPeerInfo') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         arg0: req.tetraplets[0],arg1: req.tetraplets[1],arg2: req.tetraplets[2],arg3: req.tetraplets[3],arg4: req.tetraplets[4]
     },
 };
 resp.retCode = ResultCodes.success;
 collectPeerInfo(req.args[0], req.args[1], req.args[2], req.args[3], req.args[4], callParams); resp.result = {}

 }
 next();
 });
        

 h.use((req, resp, next) => {
 if(req.serviceId === 'callbackSrv' && req.fnName === 'collectServiceInterface') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         arg0: req.tetraplets[0],arg1: req.tetraplets[1],arg2: req.tetraplets[2]
     },
 };
 resp.retCode = ResultCodes.success;
 collectServiceInterface(req.args[0], req.args[1], req.args[2], callParams); resp.result = {}

 }
 next();
 });
        
                h.onEvent('callbackSrv', 'response', (args) => {
  
});

                h.onEvent('errorHandlingSrv', 'error', (args) => {
                    const [err] = args;
                    reject(err);
                });
            })
            .handleScriptError(reject)
            .handleTimeout(() => {
                reject('Request timed out for findAndAskNeighboursSchema');
            })
        if(config && config.ttl) {
            r.withTTL(config.ttl)
        }
        request = r.build();
    });
    peer.internals.initiateFlow(request);
    return Promise.race([promise, Promise.resolve()]);
}
      


 export function getAll(...args) {
     let peer;
     let knownPeers;
let collectPeerInfo;
let collectServiceInterface;
     let config;
     if (FluencePeer.isInstance(args[0])) {
         peer = args[0];
         knownPeers = args[1];
collectPeerInfo = args[2];
collectServiceInterface = args[3];
config = args[4];
     } else {
         peer = Fluence.getPeer();
         knownPeers = args[0];
collectPeerInfo = args[1];
collectServiceInterface = args[2];
config = args[3];
     }
    
     let request;
     const promise = new Promise((resolve, reject) => {
         const r = new RequestFlowBuilder()
                 .disableInjections()
                 .withRawScript(
                     `
     (xor
 (seq
  (seq
   (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
   (call %init_peer_id% ("getDataSrv" "knownPeers") [] knownPeers)
  )
  (xor
   (fold knownPeers peer
    (par
     (seq
      (call -relay- ("op" "noop") [])
      (xor
       (seq
        (seq
         (seq
          (seq
           (seq
            (seq
             (seq
              (call peer ("peer" "identify") [] ident)
              (call peer ("dist" "list_blueprints") [] blueprints)
             )
             (call peer ("dist" "list_modules") [] modules)
            )
            (call peer ("srv" "list") [] services)
           )
           (call -relay- ("op" "noop") [])
          )
          (xor
           (call %init_peer_id% ("callbackSrv" "collectPeerInfo") [peer ident services blueprints modules])
           (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
          )
         )
         (call -relay- ("op" "noop") [])
        )
        (fold services srv
         (par
          (seq
           (call -relay- ("op" "noop") [])
           (xor
            (seq
             (seq
              (call peer ("srv" "get_interface") [srv.$.id!] iface)
              (call -relay- ("op" "noop") [])
             )
             (xor
              (call %init_peer_id% ("callbackSrv" "collectServiceInterface") [peer srv.$.id! iface])
              (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
             )
            )
            (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 3])
           )
          )
          (seq
           (call -relay- ("op" "noop") [])
           (next srv)
          )
         )
        )
       )
       (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 4])
      )
     )
     (next peer)
    )
   )
   (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 5])
  )
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 6])
)

                 `,
                 )
                 .configHandler((h) => {
                     h.on('getDataSrv', '-relay-', () => {
                    return peer.getStatus().relayPeerId;
                });
                h.on('getDataSrv', 'knownPeers', () => {return knownPeers;});

 h.use((req, resp, next) => {
 if(req.serviceId === 'callbackSrv' && req.fnName === 'collectPeerInfo') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         arg0: req.tetraplets[0],arg1: req.tetraplets[1],arg2: req.tetraplets[2],arg3: req.tetraplets[3],arg4: req.tetraplets[4]
     },
 };
 resp.retCode = ResultCodes.success;
 collectPeerInfo(req.args[0], req.args[1], req.args[2], req.args[3], req.args[4], callParams); resp.result = {}

 }
 next();
 });
        

 h.use((req, resp, next) => {
 if(req.serviceId === 'callbackSrv' && req.fnName === 'collectServiceInterface') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         arg0: req.tetraplets[0],arg1: req.tetraplets[1],arg2: req.tetraplets[2]
     },
 };
 resp.retCode = ResultCodes.success;
 collectServiceInterface(req.args[0], req.args[1], req.args[2], callParams); resp.result = {}

 }
 next();
 });
        
                h.onEvent('callbackSrv', 'response', (args) => {
  
});

                h.onEvent('errorHandlingSrv', 'error', (args) => {
                    const [err] = args;
                    reject(err);
                });
            })
            .handleScriptError(reject)
            .handleTimeout(() => {
                reject('Request timed out for getAll');
            })
        if(config && config.ttl) {
            r.withTTL(config.ttl)
        }
        request = r.build();
    });
    peer.internals.initiateFlow(request);
    return Promise.race([promise, Promise.resolve()]);
}
      
